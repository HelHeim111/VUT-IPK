# IPK Project 2 - ZETA: Network sniffer
This project requires to implement a basic network sniffer.

**Table of context**
1. [Language used](#language-used)
1. [License](#license)
1. [Usage](#usage)
1. [Output](#output)
1. [Implementation](#implementation)
1. [Testing](#testing)
1. [Bibliography](#bibliography)

## **Language used**

- C++

## **License**
- **MIT**

## **Usage**
Project was tested on *NixOs*.
1. To start use a commnd **make** to compile the client.
1. After that start the client by typing in CMD command **./ipk-sniffer [-i interface | --interface interface] {-p port [--tcp|-t] [--udp -u]} [--arp] [--icmp4] [--icmp6] [--igmp] [--mld] {-n num}**.

## **Output**

1. **timestamp**: time

1. **src MAC**: MAC address with : as separator

1. **dst MAC**: MAC address with : as separator

1. **frame length**: length

1. **src IP**: IP address if any (support v4 but also v6 representation according to RFC5952)

1. **dst IP**: IP address if any (support v4 but also v6 representation according to RFC5952)

1. **src port**: port number if any

1. **dst port**: port number if any

1. **byte_offset**: byte_offset_hexa byte_offset_ASCII

## **Theory**
Here is some basic theory to have better understanding of the task:
- **Interface**:  interface refers to a connection point between two devices or networks. It can be a physical interface like an Ethernet port, Wi-Fi radio, or a logical interface like a virtual LAN (VLAN) or a virtual IP address.

- **ICMPv4 packets** is a protocol used to communicate about network condition. ICMPv4 messages are typically generated by routers, switches, and other network devices when problems occur. 

- **ICMPv6 packets** is similar to ICMPv4 but is used with IPv6.

- **RFC5952** is a specification for the representation of IPv6 addresses. The standard specifies the use of lower-case letters for letters "a" through "f" in IPv6 addresses, and encourages the use of zero compression to shorten the address by omitting leading zeros in each 16-bit block. Example: *2001:0db8:85a3:0000:0000:8a2e:0370:7334*.
- **ARP frames** are used to resolve network layer addresses (IPv4 addresses) to link layer addresses (MAC addresses) in a local network. ARP frames are broadcast to all devices in the network, and the device that matches the IP address in the ARP frame responds with its MAC address.
- **NDP** is a protocol used in IPv6 networks for address auto-configuration, neighbor discovery, neighbor reachability detection, duplicate address detection, and router discovery. NDP packets are used to manage the connectivity of hosts on an IPv6 network, allowing them to discover each other and their corresponding addresses. The NDP protocol replaces the ARP.
- **MLD** packets are used in IPv6 networks to discover which multicast groups are active on a network segment. MLD is a protocol similar to IGMP.
- **IGMP** it is a network-layer protocol used by hosts and adjacent routers to establish multicast group memberships. IGMP is used by IPv4 hosts to inform adjacent multicast routers about their desire to join or leave a multicast group. 
- **RFC 3339**  is a standard format for representing date and time in machine-readable form. It defines a profile of the ISO 8601 standard, which specifies a standardized format for date and time representation.
        
## **Implementation**
### **Parsing arguments**

For parsing input arguments was used function:
```cpp
static struct option long_options[]{
        {"interface", required_argument, 0, 'i'},
        {"tcp", no_argument, 0, 't'},
        {"udp", no_argument, 0, 'u'},
        {"arp", no_argument, 0, 1},
        {"icmp4", no_argument, 0, 2},
        {"icmp6", no_argument, 0, 3},
        {"igmp", no_argument, 0, 4},
        {"mld", no_argument, 0, 5},
        {"ndp", no_argument, 0, 6}
     };

getopt_long(argc, argv, "i:p:tun:", long_options, NULL);
```
### **Capture network traffic**
To do this I used function *pcap_open_live()*:
```cpp
pcap_t* pcap_open_live(const char* device, int snaplen, int promisc, int to_ms, char* errbuf)
``` 
where:
- *device*: a string that specifies the name of the network interface to capture traffic on. This can be obtained using the pcap_findalldevs() function.
- *snaplen*: the maximum number of bytes to capture for each packet.
promisc: a flag that enables or disables promiscuous mode. If set to 1, the interface will capture all traffic that it sees, not just traffic that is addressed to it.
- *to_ms*: the timeout for the pcap_next() function, which reads packets from the capture buffer. This is the amount of time that pcap_next() will wait for a packet to arrive before returning.
- *errbuf*: a buffer to hold any error messages that might occur during the capture process.

### **Filter**
For this purpose i have wrote function that creates appends string with filters and returns it.
```cpp
string create_filter(string filter);
```
Then filter is being compiled into BPF (Berkeley Packet Filter) program with function:
```cpp
pcap_compile(handle, &bpf, filter.c_str(), 0, mask);
```
Finally BPF program is being applied with function:
```cpp
pcap_setfilter(handle, &bpf);
``` 

### **Handling packets**
Handling starts with function:
```cpp
pcap_loop(handle, num, packet_handler, nullptr);
```
It allows you to specify a callback function that will be called for each captured packet and takes following parameters:
- *pcap_t \**: A pointer to the pcap_t structure returned by pcap_open_live or pcap_open_offline.
- *int*: The number of packets to capture before returning (use -1 to capture indefinitely).
- *pcap_handler*: A function pointer to the callback function that will be called for each captured packet.
- *u_char \**: A pointer to user data that will be passed to the callback function.

Then I wrote function *packet_handler()*
```cpp
void packet_handler(u_char *args, const struct pcap_pkthdr* header, const u_char* packet);
```
It statrs with initing variables with struct data types:
```cpp
const struct ether_header* eh = (const struct ether_header *)packet;
const struct ip* ip = (const struct ip *)(packet + sizeof(struct ether_header));
struct tcphdr* tcp = (struct tcphdr *)(packet + sizeof(struct ether_header) + (ip->ip_hl * 4));
struct udphdr* udp = (struct udphdr *)(packet + sizeof(struct ether_header) + (ip->ip_hl * 4));
```
where:
- *eh* is an Ethernet type, it will be used to detect IPv4, IPv6 and ARP, also to get MAC adress.
- *ip* is an ip structure fo IPv4.
- *tcp* is a structure which i used to handle tcp ports.
- *udp* is a structure which i used to handle udp ports.
### **Timestamp**
For this purposes i used function *strftime()* from library *<time.h>* and for miliseconds was used casting from library *<ctime>*.
```cpp
char timestamp[64];
strftime(timestamp, sizeof(timestamp), "%Y-%m-%dT%H:%M:%S", gmtime(&current_time));
auto ms = chrono::duration_cast<chrono::milliseconds>(chrono::system_clock::now().time_since_epoch()).count() % 1000;
```
### **IPv4**
IPv4 is detected if ntohs(eh->ether_type) == ETHERTYPE_IP. To get ip was used function:
```cpp
inet_ntop(AF_INET, &(ip->ip_src), ipv4_src, INET_ADDRSTRLEN);
inet_ntop(AF_INET, &(ip->ip_dst), ipv4_dst, INET_ADDRSTRLEN);
```
After that defines protocol type, whether it is tcp or udp, so it could print out the correct port.
### **IPv6**
IPv6 is inplemented similarly to the IPv4 but instead of *struct ip* is used *struct ip6*:
```cpp
struct ip6_hdr* ipv6 = (struct ip6_hdr*) ip;
```
### **ARP**
ARP does not have ports so tcp and udp are not used here.  Also is used *struct ether_arp*:
```cpp
struct ether_arp * arp = (struct ether_arp*)(packet + sizeof(struct ether_header));
```
### **Packet data**
For printing outpacket data is being used user function
```cpp
void packet_output(const u_char *packet, int len);
``` 
It prints data line by line firsly writing offset, then hexadecimal bytes and finally ASCII symbols.
### **End**
Program ends with function that stops packet handling:
```cpp
pcap_close(handle);
```

## **Testing**
Sniffer was tested in *NixOs*. For testing were used python scripts that send package for sniffer to catch it. Tests were written by *xassat00@stud.fit.vutbr.cz*

- **Test**: no interface

    **Output**:
    ```
    sudo ./ipk-sniffer -i
    ./ipk-sniffer: option requires an argument -- 'i'
    List of all interfaces:
    enp0s3
    any
    lo
    nflog
    nfqueue
    ```

- **Test**: wrong arguments

    **Output**:
    ```
    sudo ./ipk-sniffer -i enp0s3 --app
    ./ipk-sniffer: unrecognized option '--app'
    Usage: ./ipk-sniffer [-i interface | --interface interface] {-p port [--tcp|-t] [--udp|-u]} [--arp] [--icmp4] [--icmp6] [--igmp] [--mld] {-n num}
    ```
- **Test**: arp.py

    **Output**:
    ```
    sudo ./ipk-sniffer -i enp0s3 --arp
    timestamp: 2023-04-17T19:29:29.887
    src MAC: 08:00:27:56:AA:92
    dst MAC: FF:FF:FF:FF:FF:FF
    frame length: 2054 bytes
    src IP: 192.168.1.1
    dst IP: 192.168.1.2
    
    0x0000:ff ff ff ff ff ff 08 00 27 56 aa 92 08 06 00 01 ........ 'V......
    0x0010:08 00 06 04 00 01 ff ff ff ff ff ff c0 a8 01 01 ........ ........
    0x0020:00 00 00 00 00 00 c0 a8 01 02                   ........ ..
    ```

- **Test**: igmp.py

    **Output**:
    ```
    sudo ./ipk-sniffer -i enp0s3 --igmp
    timestamp: 2023-04-17T19:59:48.127
    src MAC: 08:00:27:56:AA:92
    dst MAC: 01:00:5E:00:00:01
    frame length: 2048 bytes
    src IP: 10.0.2.15
    dst IP: 224.0.0.1

    0x0000:01 00 5e 00 00 01 08 00 27 56 aa 92 08 00 45 00 ..^..... 'V....E.
    0x0010:00 1c 00 01 00 00 01 02 cd cf 0a 00 02 0f e0 00 ........ ........
    0x0020:00 01 11 14 ee eb 00 00 00 00                   ........ ..
    ```

- **Test**: icmpv6.py

    **Output**:
    ```
    sudo ./ipk-sniffer -i enp0s3 --icmp6
    timestamp: 2023-04-17T20:00:48.670
    src MAC: 08:00:27:56:AA:92
    dst MAC: 33:33:FF:81:68:99
    frame length: 34525 bytes
    src IP: fe80::a00:27ff:fe56:aa92
    dst IP: ff02::1:ff81:6899

    0x0000:33 33 ff 81 68 99 08 00 27 56 aa 92 86 dd 60 00 33..h... 'V....`.
    0x0010:00 00 00 20 3a ff fe 80 00 00 00 00 00 00 0a 00 ... :... ........
    0x0020:27 ff fe 56 aa 92 ff 02 00 00 00 00 00 00 00 00 '..V.... ........
    0x0030:00 01 ff 81 68 99 87 00 e4 a0 00 00 00 00 fe 80 ....h... ........
    0x0040:00 00 00 00 00 00 90 ce 18 27 68 81 68 99 01 01 ........ .'h.h...
    0x0050:08 00 27 56 aa 92                               ..'V..
    ```

## **Bibliography**
1. [https://vichargrave.github.io/programming/develop-a-packet-sniffer-with-libpcap/ ](https://vichargrave.github.io/programming/develop-a-packet-sniffer-with-libpcap/) Used in lines of code 248-328.
1. [https://cplusplus.com/reference/ctime/](https://cplusplus.com/reference/ctime/) Used in lines of code 151.
1. [https://www.tcpdump.org/pcap.html](https://www.tcpdump.org/pcap.html) Used in lines of code 343.
1. [https://www.tcpdump.org/manpages/pcap-filter.7.html](https://www.tcpdump.org/manpages/pcap-filter.7.html) Used in lines of code 119-130.
1. [http://recursos.aldabaknocking.com/libpcapHakin9LuisMartinGarcia.pdf](http://recursos.aldabaknocking.com/libpcapHakin9LuisMartinGarcia.pdf)
1. [paessler.com/it-explained/packet-sniffing](paessler.com/it-explained/packet-sniffing)
1. [https://www.gnu.org/software/libc/manual/html_node/Example-of-Getopt.html](https://www.gnu.org/software/libc/manual/html_node/Example-of-Getopt.html) Used in lines of code 249.
1. [https://stackoverflow.com/questions/63250643/how-can-i-print-whole-data-of-a-packet-in-c](https://stackoverflow.com/questions/63250643/how-can-i-print-whole-data-of-a-packet-in-c) Used in lines of code 26-60.